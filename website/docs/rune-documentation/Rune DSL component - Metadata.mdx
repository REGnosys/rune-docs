---
sidebar_position: 6
---

**Rune DSL component - Metadata component**

Metadata components add extra information to model elements like data types, attributes, and functions.

Most components can include a plain‑text description. These descriptions don't produce code, but they can provide important metadata and should be included for every model component, written clearly and completely.

**Syntax**

To add a text description to a model component, place the text in double quote marks inside angle brackets: &lt;"…"&gt;.

[//]: # (| You can attach descriptions to almost any component, including: | \- Data types<br><br>\- Attributes<br><br>\- Conditions<br><br>\- Functions<br><br>\- Inputs and outputs<br><br>\- Business logic<br><br>\- Reporting rules<br><br>\- Namespaces |)
[//]: # (| --- | --- |)

1. Annotations
2. Document reference
3. Cross-referencing

**Annotations**

Annotations add extra metadata to model components beyond plain descriptions. They can:

- enforce constraints during validation
- change how the model behaves in generated code
- provide guidance when navigating the model.

**Syntax**

[//]: # (| Annotations are defined with the annotation keyword: | **annotation** **<**annotationName**\>:** **<**"Description"**\>**<br><br>**<**attribute1**\>**<br><br>**<**attribute2**\>**<br><br>**&lt;...&gt;** |)
[//]: # (| --- | --- |)
[//]: # (| Annotation names use **lower camelCase** and must be unique within a model. Attributes are optional - many annotations won't need any. | annotation rootType: &lt;"Mark a type as a root of the rune model"&gt; |)
[//]: # (| Rune DSL includes some built‑in annotations, but you can define your own as needed.<br><br>Once defined, you can apply an annotation to any model component using its name and any chosen attributes. | \[**<**annotationName**\>** &#40;optional**:** **<**annotationAttribute**\>**&#41;\] |)

**Annotation:** codeimplementation

[//]: # (| The codeImplementation annotation tells users that a function's logic is implemented elsewhere in the codebase - for example, in a static, handwritten Java class.<br><br>Functions marked with this annotation should not include any Rune implementation - their behavior is provided by the external code. | **Example**<br><br>func MyFunc:<br><br>\[codeImplementation\]<br><br>inputs:<br><br>myInput string &#40;1..1&#41;<br><br>output:<br><br>myOutput string &#40;1..1&#41; |)
[//]: # (| --- | --- |)

**Annotation:** metadata

The metadata annotation defines qualifiers that can be applied to a data type or attribute.

[//]: # (| Rune provides several built‑in metadata fields: | annotation metadata:<br><br>id string &#40;0..1&#41;<br><br>key string &#40;0..1&#41;<br><br>scheme string &#40;0..1&#41;<br><br>reference string &#40;0..1&#41;<br><br>template string &#40;0..1&#41;<br><br>location string &#40;0..1&#41; &lt;"Specifies this is the target of an internal reference"&gt;<br><br>address string &#40;0..1&#41; &lt;"Specified that this is an internal reference to an object that appears elsewhere"&gt; |)
[//]: # (| --- | --- |)

Each metadata field represents a different qualifier:

- scheme: Controls the allowed values for an attribute without needing an enumeration. The attribute is usually a simple string, and the annotation tells the system where to source the scheme values.
- template: Marks that a data type can be used as a data template, allowing shared data to be stored once and referenced by multiple objects.
- **Other fields**: Used for cross‑referencing between objects.

**Using metadata in functions and expressions**

You can access metadata values through function inputs or expression outputs that have metadata annotations.

[//]: # (| How a function can use metadata passed into it. | func MyFunc:<br><br>inputs:<br><br>myInput string &#40;1..1&#41;<br><br>\[metadata scheme\]<br><br>output:<br><br>myResult string &#40;1..1&#41;<br><br>set myResult: myInput -> scheme |)
[//]: # (| --- | --- |)
[//]: # (| How to work with metadata that is the output of an expression: | func MyFunc:<br><br>inputs:<br><br>myInput string &#40;1..\*&#41;<br><br>\[metadata scheme\]<br><br>output:<br><br>myResult string &#40;1..\*&#41;<br><br>set myResult: myInput extract scheme |)

**Document reference**

A document reference is an annotation that links model components to information stored in an external document. In Rune, you can define these external documents - who owns them and key parts of their content - as model components, and then associate them with other elements like data types or functions.

If the external information is plain text, this creates a built‑in documentation trail for model behavior. When that behavior is later turned into executable software, the document reference acts as a form of self‑documentation.

Document references consist of two parts: **hierarchy** and **content**.

**Document hierarchy**

Document hierarchy uses three keywords to structure document references:

- body - the author, publisher, or owner of the document
- corpus - the document set containing the referenced material
- segment - the specific section within a document

[//]: # (| The syntax to define a body, corpus and segment: | **body** **&lt;BodyType&gt;** **&lt;BodyName&gt;** &#40;optional**:** **<**"Description"**\>**&#41;<br><br>**corpus** **&lt;CorpusType&gt;** &#40;optional**:** **&lt;Body&gt;**&#41; &#40;optional**:** **<**"Alias"**\>**&#41; **&lt;CorpusName&gt;** &#40;optional**:** **<**"Description"**\>**&#41;<br><br>**segment** **<**segmentType**\>** |)
[//]: # (| --- | --- |)
[//]: # (| **Bodies** may include regulatory authorities or trade associations. | **body** **Authority** **EuropeanCommission** **<**"European Commission &#40;ec.europa.eu&#41;."**\>** |)
[//]: # (| **Corpuses** represent document sets such as directives, laws, regulatory texts, technical standards, or best‑practice guidance.<br><br>A corpus may also include an **alias**, which provides an alternative identifier such as an official document number. | corpus Directive "93/59/EC" StandardEmissionsEuro1<br><br>&lt;"COUNCIL DIRECTIVE 93 /59/EEC of 28 June 1993 amending Directive 70/220/EEC on the approximation of the laws of the Member States relating to measures to be taken against air pollution by emissions from motor vehicles <https://eur-lex.europa.eu/legal-content/EN/ALL/?uri=CELEX%3A31993L0059>"&gt; |)
[//]: # (| **Segments** refer to a specific section in a document &#40;as opposed to corpuses, which are typically large document sets with many provisions, clauses etc&#41;. | **segment** article<br><br>**segment** whereas<br><br>**segment** annex<br><br>**segment** table |)
[//]: # (| A segment is referenced by giving it a free‑text name or number. | &lt;segmentType&gt; &lt;"SegmentID"&gt; |)
[//]: # (| Multiple segments can be chained to point to an exact location in a document. | article "26" paragraph "2" |)

**Document content**

**Document content** is referenced using the docReference keyword. Each reference must point to a **corpus** and one or more **segments** defined in the document hierarchy. Document references can be attached to any type, attribute, function, or rule.

[//]: # (| You can use the provision keyword to include the specific text being referenced. | \[docReference **&lt;Body&gt;** **&lt;Corpus&gt;**<br><br>**<**segment1**\>** **<**segment2**\>** **&lt;...&gt;**<br><br>provision **<**"ProvisionText"**\>**\] |)
[//]: # (| --- | --- |)

Sometimes a data type may use a different name depending on context - for example, a legal definition may refer to the same concept using another term.

[//]: # (| For example, you can define a special segment such as namingConvention: | **segment** namingConvention<br><br>**type** **PayerReceiver:** **<**"Specifies the parties responsible for making and receiving payments defined by this structure."**\>**<br><br>payer **CounterpartyRoleEnum** &#40;1**..**1&#41;<br><br>\[docReference **ICMA** **GMRA**<br><br>namingConvention "seller"<br><br>provision "As defined in the GRMA Seller party ..."\]<br><br>**&lt;...&gt;** |)
[//]: # (| --- | --- |)

**Document reference on a path**

You cannot attach a document reference directly to an attribute. Instead, you'll need to define it on a root type using an annotation path.

[//]: # (| For example, the payer attribute under Report -> leg1 -> payerReceiver can be annotated like this: | type Report:<br><br>leg1 Leg &#40;1..1&#41;<br><br>\[docReference for payerReceiver -> payer ICMA GMRA<br><br>namingConvention "seller"<br><br>provision "As defined in the GRMA Seller party ..."\]<br><br>&lt;...&gt; |)
[//]: # (| --- | --- |)

In general, the path must start with the keyword for, followed by one of these:

- An attribute name e.g. payerReceiver
- A path to an attribute e.g. payerReceiver -> payer
- The keyword item to refer to the attribute itself
- A deep path in a choice type e.g. item ->> dayCountConvention (see the [deep path operator](https://docs.rosetta-technology.io/rosetta/rune-dsl/rune-modelling-component/))

**Data template**

When a data type is marked as a **template**, it can reference a separate template object. Both the template and any object that uses it are usually incomplete and should not be validated on their own. After resolving the template reference, the template data must be merged into the object to create a fully populated object. Validation should only happen after this merge.

Aside from the annotation itself, templates do not change the model - they do not add new types, attributes or conditions.

Template designation also applies to all encapsulated types within the annotated type.

[//]: # (| In this example, marking ContractualProduct as a template also makes EconomicTerms &#40;and all types inside it&#41; eligible for the template: | type ContractualProduct:<br><br>\[metadata key\]<br><br>\[metadata template\]<br><br>productIdentification ProductIdentification &#40;0..1&#41;<br><br>productTaxonomy ProductTaxonomy &#40;0..\*&#41;<br><br>economicTerms EconomicTerms &#40;1..1&#41; |)
[//]: # (| --- | --- |)

**Cross-referencing**

**Cross‑referencing** lets an attribute point to an object located elsewhere in the model. The source object carries a metadata identifier, and the target attribute stores that identifier instead of a normal value.

**Syntax**

Cross‑referencing uses the key (or id) and reference metadata pair.

- key or id marks the source object.
- id is used when annotating built‑in types, since they have no data type to attach a key to.

[//]: # (| An attribute annotated with reference metadata can either hold a normal value or a key that points to the source.<br><br>Any attribute marked as a reference must refer to a type annotated with a key. | &lt;SourceType&gt;<br><br>\[metadata key\]<br><br>// For built-in types only:<br><br>&lt;sourceAttribute&gt;<br><br>\[metadata id\]<br><br>&lt;targetAttribute&gt;<br><br>\[metadata reference\] |)
[//]: # (| --- | --- |)

[//]: # (| Party and Identifier types show how cross‑reference annotations work. Marking Party with a key makes it referenceable. In Identifier, the reference annotation on issuerReference means this attribute can point to a Party using its key instead of duplicating the full object. | type Party:<br><br>\[metadata key\]<br><br>partyId string &#40;1..\*&#41;<br><br>\[metadata scheme\]<br><br>name string &#40;0..1&#41;<br><br>\[metadata scheme\]<br><br>person NaturalPerson &#40;0..\*&#41;<br><br>account Account &#40;0..1&#41;<br><br>type Identifier:<br><br>\[metadata key\]<br><br>issuerReference Party &#40;0..1&#41;<br><br>\[metadata reference\]<br><br>issuer string &#40;0..1&#41;<br><br>\[metadata scheme\]<br><br>assignedIdentifier AssignedIdentifier &#40;1..\*&#41; |)
[//]: # (| --- | --- |)

**Reference types**

Rune currently supports three different reference types, each with a different scope.

**1. Global reference**

A **global reference** uses the key or id metadata annotations to generate a globally unique identifier for a type. This identifier is a hash created by the model implementation. An attribute marked with reference can then use that key, even if the referenced object is defined elsewhere.

In Rune's default implementation, these fields are named globalKey and globalReference. The global key is a _deep hash_ built from all attribute values of the data type, including nested attributes.

**2. External reference**

Objects annotated with key or id can also carry an identifier taken from an external source - for example, an FpML id. Attributes marked with reference can then store these external identifiers. A reference‑resolver process can link the external reference back to the correct object.

[//]: # (| In this example, the party object has both a globalKey &#40;its internal unique identifier&#41; and an externalKey taken from another system. It also includes a globalReference that would resolve to that same party. | "party" : {<br><br>"meta" : {<br><br>"globalKey" : "3fa8e998",<br><br>"externalKey" : "f845ge"<br><br>},<br><br>"name" : {<br><br>"value" : "XYZ Bank"<br><br>},<br><br>"partyId" : \[ {<br><br>"value" : "XYZBICXXX",<br><br>"meta" : {<br><br>"scheme" : "<http://www.fpml.org/coding-scheme/external/iso9362>"<br><br>}<br><br>} \]<br><br>}<br><br>"partyReference" : {<br><br>"globalReference" : "3fa8e998"<br><br>} |)
[//]: # (| --- | --- |)

**3. Address and location reference**

Sometimes an attribute acts as a variable while the rest of an object stays the same. This avoids duplicating large objects that differ only in a few values. Instead, you define one parameterised object, and each instance only provides the variable values rather than copying the whole structure.

Rune supports this pattern using an address **/** location cross‑reference.

- **address** marks the placeholder where the variable value belongs (the target).
- **location** marks where the actual value is defined (the source).

[//]: # (| The syntax uses the address and location metadata pair as shown below.<br><br>**Note:** The global referencing mechanism doesn't work here because a global key is tied to an object's full set of attribute values. Here, however, the same key &#40;the variable's address&#41; must stay the same no matter what value the variable takes. | **<**targetAttribute**\>**<br><br>\[metadata address "pointsTo"**\=<**sourceAttribute**\>**\]<br><br>**<**sourceAttribute**\>**<br><br>\[metadata location\] |)
[//]: # (| --- | --- |)
